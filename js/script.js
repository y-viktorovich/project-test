"use strict";

let number = 5;
const leftBorderWidth = 1; // Камел кейс, стиль написання змінних

// snake_case, для констант
// UPPER_SNAKE_CASE, для констант
// Kebab-case, для React
// PascalCase, названня змінних

const COLOR_RED = '#F00';

number = 10;
console.log(number);


//////////////////// 11 урок - Типи данних

let numberTicket = 4;
    numberTicket = 4.6;

console.log(4/0); // Infinity Числовий тип данних показує безкінечність.
console.log(-4/0); // -Infinity Числовий тип данних показує безкінечність.
console.log('string' *9); // Nan тобто not a number

const persone = "Alex"; // Немає різниці які лапки використовувати "..." такі чи '...'. Лапки визначають стрічку.
const bool = true; // Boolean Логічне значення
// false; // Boolean Логічне значення

// console.log(something); // ReferenceError тобто посилається на неіснуючий об'єкт. Null будемо отримувати дуже рідко.

let und;
console.log(und); // Undefined показує, що змінна є, але вона не має значення, тобто невизначена.

// Symbol на практиці майже не використовується. Ми його не розглядали.
// BigInt Стосується великих чисел. Ми його не розглядали.

// const obj = { // З фігурними дужками є об'єктом, в середині має свойсто об'єкта і дії,
    // які називаються методи об'єкту.
    // name: "John",
    // age: 25,
    // isMarried: false
//};

// console.log(obj.name);
// console.log(obj["age"]); // Якщо ми бажаємо дістати значення свойства об'єкта.

// let arr = ['plum.png', 'orange.jpg', 6, 'apple.bmp', {}, []]; // Класичний масив. Можна помістити
    // будь-який тип данних.
// console.log(arr[1]); // Нумерація починається не з одиниці, а з нуля.

//////////////////// 12 Урок. Разница между объектами и массивами и неочевидные синтаксические возможности.

const arr = ['a', 'b', 'c'];

arr[10] = '3456'; // Записувати нове свойство в масив таким чином не рокомендується, бо отримаємо.
// [ 'a', 'b', 'c', <7 empty items>, '3456' ] в консолі. Тобто створяться порожні елементи, які порушать роботу масиву.

console.log(arr);

const arrObj = { // Варіант записання масиву в форматі звичайного об'єкту.
    0: 'a',
    '1': 'b',
    2: 'c', 
    abc: { // Можна створювати вложеності в об'єктах, так само як і в масивах.
        df: [{}, {}],
        def: {

        }
    }
};

const b = 'b';
// arrObj[b] = '1234'; // Так можна звертатись, якщо змінна вже існує. І можна створити нове свойство.
arrObj[b] = {}; // Так робити також нормально.
arrObj[b] = []; // Так робити також нормально.

// arrObj.b = '1234'; // Створив свойство.
// arrObj['b'] = '1234'; // Створив свойство. Квадратні скобки використовувати пріорітетніше, вони більш безпечні.
// console.log(arrObj['b']); // Можна отримати данні свойства так.
console.log(arrObj.b); // Можна отримати данні свойства так.

// console.log(arr[1]);
// console.log(arrObj.0); // Буде помилка тому, що JS не розуміє, що ти вказуєш свойство/ключ, він думає, що це цифра.
console.log(arrObj[0]); // Тут вже такої проблеми не буде.

const obj = { // В об'єктів немає чіткої нумерації.
    Anna: 500, // Можливо і так записувати без '...', об'єкт сам зрозуміє, що це стрічка.
    'Alice': 800
};

// alert('Hello');

// const result = confirm("Are you here?");
// console.log(result);

// const answer = prompt("Вам есть 18?", ""); // Вікно з placeholder де користувач має ввести відповідь. 
    // Обов'язково дописується , "".
const answer = +prompt("Вам есть 18?", ""); // Якщо буде оператор +, то данні які введе користувач,
    //   покаже числове значення.
console.log(typeof(answer + 5));
console.log(typeof(answer)); // Оператор typeof показує який тип данних знаходиться.
    //  Вся інформація, яка надходить від користувача буде у вигляді строк.

// const answers = [];

// answers[0] = prompt('Как ваше имя?', '');
// answers[1] = prompt('Как ваша фамилия?', '');
// answers[2] = prompt('Сколько вам лет?', '');

// document.write(answers); // Показує все, що ти напишеш в JS файлі до заванаження html/css.

// console.log(typeof(answers));

console.log(typeof(null)); // Покаще, що цей тип данних є об'єкт, але це помилка. Така особливість.

//////////////////// Урок 14 Інтреполяція

const category = 'toys';


// console.log('https://someurl.com/' + category + '/' + '4'); // Класичний застрілий спосіб.
console.log(`https://someurl.com/${category}/5`); // Якщо косі `...`, то можна таким чином додавати
    // змінні і дописувати все без +

// const user = "Ivan";
// alert(`Привет, ${user}`);

//////////////////// Урок 14 Оператори

console.log('arr' + " - object");
console.log(4 + " - object");
// console.log(4 + +" - object");
// console.log(4 + +"5");

let incr = 10,
    decr = 10;

incr++; // Оператор інкременту. Оператор інкременту. Якщо їх ставимо в кінці, то це посвікстний.
decr--;

// ++incr; // Оператор інкременту. Якщо їх ставимо на початку, то це префіксний.
// --decr;

// console.log(incr++); // Якщо запишемо так, то не спрацює, тому що повертає в початкове значення.
// console.log(decr--);

console.log(++incr); // Так виведе результат.
console.log(--decr);

console.log(5%2); // Ділимо 5 на 2 і в консолі вибиває "1", залишок, що залишився від ділення.

// Знак = це присвоювання.

console.log(2*4 == 8); // == Цем знаком зрівнюємо.


console.log(2*4 == '8'); // Так також буде працювати тому, що ми порівнюємо значення, а не тип данних.

console.log(2*4 === '8'); // === Порівняння по типу данних.

console.log(2*4 === 8);


console.log(2 + 2 * 2 != 8); // != нерівний.
console.log(2 + 2 * 2 !== '6'); // !== нерівний. Суворе зрівняння по типу.


const isCheked = true,
      isClose = false;

// && // Оператор І. Показує true, якщо у всіх змінних true. Якщо два, або більше подібних, тільки тоді працює.
// || // Оператор Ілі. Показує true, якщо хоч одна зі змінних true.

// console.log(isCheked && isClose);
console.log(isCheked || isClose); // Покаже true тому, що хоча б один
// з аргументів буде правдивим. Хоча б один є правдивим.

console.log(isCheked || !isClose); // Оператор отрицания робить значення протилежне.


